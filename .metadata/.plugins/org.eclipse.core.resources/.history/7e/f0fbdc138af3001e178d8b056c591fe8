/*
 * AHT20.c
 *
 *  Created on: Apr 4, 2024
 *      Author: kuba
 */

#include "AHT20.h"

HAL_StatusTypeDef AHT20_Master_Transmit(uint8_t data, uint16_t size)
{
	HAL_StatusTypeDef status;
	status = HAL_I2C_Master_Transmit(&hi2c1, AHT20_ADDR, &data, size, HAL_MAX_DELAY);

	return status;
}

HAL_StatusTypeDef AHT20_Master_Receive(uint8_t data, uint16_t size)
{
	HAL_StatusTypeDef status;
	status = HAL_I2C_Master_Receive(&hi2c1, AHT20_READ_ADDR, &data, size, HAL_MAX_DELAY);

	return status;
}

HAL_StatusTypeDef AHT20_Write_Reg(uint8_t reg, uint8_t write_value)
{
	HAL_StatusTypeDef status;
	status = HAL_I2C_Mem_Write(&hi2c1, AHT20_ADDR, reg, 1, &write_value, sizeof(write_value), HAL_MAX_DELAY);

	return status;
}

uint8_t AHT20_Read_Reg(uint8_t reg)
{
	uint8_t read_value = 0;
	HAL_I2C_Mem_Read(&hi2c1, AHT20_ADDR, reg, 1, &read_value, sizeof(read_value), HAL_MAX_DELAY);

	return read_value;
}

void AHT20_Init()
{
	uint8_t init_cmd[] = {0xBE, 0x08, 0x00};
	if (AHT20_Master_Transmit(init_cmd, sizeof(init_cmd)) != HAL_OK)
	{
		printf("AHT20 initialisation error\n");
	}
	else
	{
		printf("AHT20 initialised\n");
		uint8_t value = 0x00;
		HAL_Delay(10);
		value = AHT20_Read_Reg(AHT20_READ_ADDR); // AHT20_master_receive(value, sizeof(value)); // TODO: test this
//		printf("value: 0x%02X\n", value);
		if ((value & (1 << 3)) != 0) // check calibration bit
		{
			printf("AHT20 calibrated\n");
		}
		else
		{
			printf("AHT20 not calibrated\n");
		}
	}
}

void AHT20_Trig_Measure()
{
	uint8_t trig_measure_cmd[] = {0xAC, 0x33, 0x00};
	if (AHT20_Master_Transmit(trig_measure_cmd, sizeof(trig_measure_cmd)) != HAL_OK)
	{
		printf("AHT20 trigger measurement error\n");
	}
	else
	{
		uint8_t value = 0xFF;
		do
		{
			HAL_Delay(80); // wait for the measurements to be completed
			value = AHT20_Read_Reg(AHT20_READ_ADDR);
		}
		while ((value & (1 << 7)) != 0); // bit[7] = 0 indicated completed measurements

		// reading measurements

	}
}
